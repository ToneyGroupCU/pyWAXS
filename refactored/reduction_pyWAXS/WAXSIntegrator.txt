## -- WAXSIntegrator Scripts -- ##


'''
        # # Step 2: Coordinate Conversion
        # qxy = img[qxy_dim]
        # qz = img[qz_dim]

        # # Debugging: Check the range of qxy, qz, chi, and qr
        # print(f"qxy range: {qxy.min().item()}, {qxy.max().item()}")
        # print(f"qz range: {qz.min().item()}, {qz.max().item()}")

        # chi = np.arctan2(qz, qxy) * (180 / np.pi)
        # qr = np.sqrt(qxy**2 + qz**2)

        # print(f"chi range: {chi.min().item()}, {chi.max().item()}")
        # print(f"qr range: {qr.min().item()}, {qr.max().item()}")
        
        # # Step 3: Masking and Slicing
        # # mask = (chi >= chi_min) & (chi <= chi_max) & (qr >= qr_min) & (qr <= qr_max)
        # # self.azimuth_mask = mask
        # # self.original_total_intensity = img.where(mask).sum().item()

        # # # Step 4: Construct the Azimuthal Matrix
        # # A = self._create_azimuthal_matrix(chi, qr, mask, chi_range, qr_range, discretization, sum_direction)
        
        # # # Step 5: Azimuthal Summation Using Sparse Matrix
        # # I = img.values.flatten()
        # # S = A.dot(I)
        
        # chi, qr = self.convert_to_chi_qr(img.coords['qxy'].values, img.coords['qz'].values)

        # mask = (chi >= chi_range[0]) & (chi <= chi_range[1]) & (qr >= qr_range[0]) & (qr <= qr_range[1])
        # img_masked = img.where(mask)

        # self.azimuth_mask = img_masked
        # self.original_total_intensity = img.where(mask).sum().item()
        
        # # Convert to chi and qr space
        # img_transformed = self.convert_to_chi_qr(img.coords['qxy'].values, img.coords['qz'].values)

        # # Interpolate along chi
        # img_interpolated = self.interpolate_along_chi(chi, qr, img_transformed)

        # # Your existing azimuthal integration code here, now working on img_interpolated
        # self.azimuth1D_xr_sum = xr.DataArray(img_interpolated, coords=[np.arange(chi_range[0], chi_range[1], discretization) if sum_direction == 'chi' else np.arange(qr_range[0], qr_range[1], discretization)], dims=[sum_direction])

        # # return img_interpolated
        
        # # Step 6: Verification of Pixel Splitting
        # if not np.isclose(self.azimuth1D_xr_sum.sum().item(), self.original_total_intensity, atol=1e-6):
        #     raise ValueError("Pixel splitting error: Total intensity mismatch.")
            
        # return self.azimuth1D_xr_sum
        '''

''' # class AzimuthalIntegrator:
# Define the methods and functions
class AzimuthalIntegrator:

    @staticmethod
    def convert_to_chi_qr(qxy, qz):
        qxy_mesh, qz_mesh = np.meshgrid(qxy, qz)
        chi = np.arctan2(qz_mesh, qxy_mesh) * (180 / np.pi)
        qr = np.sqrt(qxy_mesh ** 2 + qz_mesh ** 2)
        return chi, qr

    @staticmethod
    def interpolate_along_chi(chi, qr, img):
        chi_values = np.unique(chi)
        interpolated_img = np.zeros_like(img)

        for chi_val in chi_values:
            mask = chi == chi_val
            qr_values = qr[mask]
            img_values = img[mask]
            if len(qr_values) < 2:
                continue
            interpolator = interp1d(qr_values, img_values, kind='linear', fill_value='extrapolate')
            interpolated_img[mask] = interpolator(qr[mask])

        return interpolated_img

    def azimuth1D(self, img, chi_range, qr_range, sum_direction, discretization=0.1):
        qz_aliases = ['qz', 'q_z', 'QZ', 'Q_z', 'Q_Z']
        qxy_aliases = ['qxy', 'q_xy', 'QXY', 'Qxy', 'Q_xy', 'Q_XY']

        qz_dim = None
        qxy_dim = None
        for dim in img.dims:
            if dim in qz_aliases:
                qz_dim = dim
            if dim in qxy_aliases:
                qxy_dim = dim

        if qz_dim is None or qxy_dim is None:
            raise ValueError("The input DataArray must have 'qxy' or an alias and 'qz' or an alias as dimensions.")

        chi_min, chi_max = chi_range
        qr_min, qr_max = qr_range

        if sum_direction not in ['chi', 'qr']:
            raise ValueError("Invalid sum_direction. Choose either 'chi' or 'qr'.")

        qxy = img.coords[qxy_dim].values
        qz = img.coords[qz_dim].values

        chi, qr = self.convert_to_chi_qr(qxy, qz)

        mask = (chi >= chi_range[0]) & (chi <= chi_range[1]) & (qr >= qr_range[0]) & (qr <= qr_range[1])
        img_masked = img.where(mask)
        self.azimuth_mask = img_masked
        self.original_total_intensity = img.where(mask).sum().item()

        img_interpolated = self.interpolate_along_chi(chi, qr, img_masked.values)

        self.azimuth1D_xr_sum = xr.DataArray(img_interpolated, 
            coords=[np.arange(chi_range[0], chi_range[1], discretization) if sum_direction == 'chi' else np.arange(qr_range[0], qr_range[1], discretization)], 
            dims=[sum_direction])

        return self.azimuth1D_xr_sum

    def generate_test_data(self, shape=(100, 100), num_arcs=3, arc_width=3):
        y, x = np.ogrid[-shape[0]//2:shape[0]//2, -shape[1]//2:shape[1]//2]
        mask = np.zeros(shape)
        for i in range(num_arcs):
            radius_inner = i * (arc_width + 5)
            radius_outer = radius_inner + arc_width
            mask_arc = (x ** 2 + y ** 2 >= radius_inner ** 2) & (x ** 2 + y ** 2 < radius_outer ** 2)
            mask += mask_arc

        mask = mask * (y >= 0)

        test_data = xr.DataArray(mask, coords=[('qz', np.linspace(-1, 1, shape[0])), ('qxy', np.linspace(-1, 1, shape[1]))])
        return test_data
    
    @staticmethod
    def generate_test_data(qxy_min, qxy_max, qz_min, qz_max, num_points):
        """
        Generate a test dataset simulating concentric half arcs in qxy vs qz space.
        
        Parameters:
        - qxy_min, qxy_max: Min and max values for qxy coordinate.
        - qz_min, qz_max: Min and max values for qz coordinate.
        - num_points: Number of points along each dimension.
        
        Returns: 
        - test_data: 2D Xarray DataArray representing the test data.
        """
        qxy_values = np.linspace(qxy_min, qxy_max, num_points)
        qz_values = np.linspace(qz_min, qz_max, num_points)
        test_data = np.zeros((num_points, num_points))
        
        for i in range(num_points):
            for j in range(num_points):
                qxy = qxy_values[j]
                qz = qz_values[i]
                r = np.sqrt(qxy**2 + qz**2)
                
                # Create concentric half arcs
                if 0.5 <= r <= 0.6 or 0.9 <= r <= 1.0:
                    angle = np.arctan2(qz, qxy) * (180 / np.pi)
                    if 0 <= angle <= 180:
                        test_data[i, j] = 1

        coords = {'qxy': qxy_values, 'qz': qz_values}
        test_data = xr.DataArray(test_data, coords=coords, dims=['qz', 'qxy'])
        return test_data
    
    @staticmethod
    def plot_test_data(test_data):
        """
        Plot the test data in qxy vs qz space.
        
        Parameters:
        - test_data: 2D Xarray DataArray representing the test data.
        """
        plt.imshow(test_data, origin='lower', aspect='auto', extent=[test_data.qxy.min(), test_data.qxy.max(), test_data.qz.min(), test_data.qz.max()])
        plt.colorbar(label='Intensity')
        plt.xlabel('qxy')
        plt.ylabel('qz')
        plt.title('Test Data (qxy vs qz)')
        plt.show()

    def convert_to_chi_qr(qxy, qz):
        chi = np.arctan2(qz, qxy) * (180 / np.pi)
        qr = np.sqrt(qxy**2 + qz**2)
        return chi, qr

    def generate_mock_data_with_variable_intensity(size=200, num_arcs=5, intensity_base=100, intensity_variation=20):
        x, y = np.linspace(-size // 2, size // 2, size), np.linspace(-size // 2, size // 2, size)
        xx, yy = np.meshgrid(x, y)
        rr = np.sqrt(xx**2 + yy**2)
        angle = np.arctan2(yy, xx)  # Angle in radians

        img = np.zeros((size, size))
        for i in range(1, num_arcs + 1):
            arc_mask = np.abs(rr - i * 10) < 1
            img[arc_mask] = intensity_base + intensity_variation * np.sin(3 * angle[arc_mask])

        img[:, :size // 2] = 0
        return img

    def angularint1D(self, img, q_range, chi_range):
        """aglint() integrate the selected sector to get intensity vs q. qp defines the number of points in q.
        A smooth option is also offered to convolute the curve."""
        data1=np.zeros([yp,xp])
        xline=np.linspace(1,xp-1,xp-1)
        xline=xline.astype(int)
        yline=np.linspace(1,yp-1,yp-1)
        yline=yline.astype(int)
        I=np.zeros(qp)
        for i in xline:
            for j in yline:
                a=(a2-a1)/xp*i+a1
                b=(a4-a3)/yp*j+a3
                q=np.sqrt(a*a+b*b)
                qi=math.floor(q/(a4/qp))
                angle=np.arccos(a/q)
                if angle>angle1:
                    if angle<angle2:
                        if q<a4:
                            if q>qqmin:
                                I[qi]=I[qi]+data[j,i]
                                data1[j,i]=data1[j,i]+data[j,i]
        return I,data1

    def optimized_angularint(a1, a2, a3, a4, qp, angle1, angle2, qqmin, xp, yp, data):
        """
        Optimized function for azimuthal integration on 2D GIWAXS data.

        Parameters:
        a1, a2, a3, a4 : float
            Limits for the a and b axes.
        qp : int
            Number of bins for integrated intensity.
        angle1, angle2 : float
            Angular limits for the integration.
        qqmin : float
            Minimum q value for the integration.
        xp, yp : int
            Dimensions of the data array.
        data : np.ndarray
            2D array containing the GIWAXS data.

        Returns:
        I : np.ndarray
            Integrated intensity as a function of q.
        data1 : np.ndarray
            Data array where only the pixels used for the integration are non-zero.
        """
        
        # Generate 2D arrays for a and b values, representing qxy and qz for each pixel
        a_values = np.linspace(a1, a2, xp)[:, None]
        b_values = np.linspace(a3, a4, yp)[None, :]
        
        # Calculate q values for each pixel
        q_values = np.sqrt(a_values**2 + b_values**2)
        
        # Calculate angles for each pixel
        angle_values = np.arccos(a_values / q_values)
        
        # Create masks for valid q and angle values
        angle_mask = (angle_values > angle1) & (angle_values < angle2)
        q_mask = (q_values < a4) & (q_values > qqmin)
        
        # Combine angle and q masks
        mask = angle_mask & q_mask
        
        # Calculate bin index for each q value
        q_indices = np.floor(q_values / (a4 / qp)).astype(int)
        
        # Initialize intensity array
        I = np.zeros(qp)
        
        # Efficiently sum up intensities using bincount
        I = np.bincount(q_indices[mask], weights=data[mask], minlength=qp)
        
        # Create output data array
        data1 = np.zeros_like(data)
        data1[mask] = data[mask]
        
        return I, data1

    # Updated 'display_image1D' method to include save_path option
    def display_image1D(self, integrator, color='red', title='1D Integrated Image', save_image=False, samplenameprefix=None, savePath=".", plot_interpolated=False):
        """
        Description: Plots a 1D DataArray using matplotlib.

        Variables:
        - integrator: The integrator object containing the 1D Xarray DataArray to be plotted.
        - color: Color of the plot line for the original data.
        - title: Title of the plot.
        - save_image: Whether to save the image as a .png file (True or False).
        - samplenameprefix: Prefix for the saved image file name if save_image is True.
        - save_path: Path where the image will be saved if save_image is True.
        - plot_interpolated: Whether to plot the interpolated data (True or False).

        Output:
        Displays the plot and optionally saves it as a .png file.
        """
        
        img1D = integrator.boxcut1D_xr  # Extract the DataArray from the integrator object

        plt.close('all')
        plt.figure(figsize=(10, 6))
        
        # Plot original data
        img1D.plot.line(color=color, label='Original')
        
        # Choose a different color for interpolated data if it matches the original color
        interp_color = 'green' if color != 'green' else 'blue'
        
        # Plot interpolated data if requested
        if plot_interpolated:
            try:
                integrator.boxcut1D_interp_xr.plot.line(color=interp_color, label='Interpolated')
            except AttributeError:
                print("Interpolated data is not available. Only original data will be plotted.")
        
        plt.ylabel('Intensity (arb. units)')
        plt.xlabel(img1D.attrs.get('sumdir', 'Coordinate'))
        plt.title(title)
        plt.grid(True)
        plt.legend()  # Add legend
            
        if save_image:
            if samplenameprefix is None:
                raise ValueError("samplenameprefix must be provided if save_image is True")
            
            timestamp = datetime.now().strftime("%y%m%d_%H%M%S")
            filename = f"{samplenameprefix}_{timestamp}.png"
            full_save_path = Path(savePath) / filename
            plt.savefig(full_save_path)
            
        plt.show()

import xarray as xr
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi
from scipy.stats import binned_statistic_2d
from scipy.spatial import ConvexHull, convex_hull_plot_2d
from scipy.spatial import Delaunay

class WAXSTest:
    def __init__(self):
        self.mask = None
        self.cropped_data = None
        self.shape = []
        self.corners = None
        self.qr_bins = None
        self.chi_bins = None

    def find_closest_point(self, pairs, target_q_xy, target_q_z, tol1=0.02, tol2=0.01):
        filtered_pairs = [pair for pair in pairs if abs(pair[0] - target_q_xy) <= tol1]
        filtered_pairs = sorted(filtered_pairs, key=lambda x: abs(x[1] - target_q_z))
        closest_by_qz = [pair for pair in filtered_pairs if abs(pair[1] - target_q_z) <= tol1]
        closest_by_qz = sorted(closest_by_qz, key=lambda x: abs(x[0] - target_q_xy))
        closest_by_qxy = [pair for pair in closest_by_qz if abs(pair[0] - target_q_xy) <= tol2]
        
        if not closest_by_qxy:  # Check if the list is empty
            return None
        
        closest_point = min(closest_by_qxy, key=lambda x: abs(x[1] - target_q_z))
        return closest_point

    @staticmethod
    def find_closest_point(pairs, target_q_xy, target_q_z, tol1=0.02, tol2=0.01):
        filtered_pairs = [pair for pair in pairs if abs(pair[0] - target_q_xy) <= tol1]
        filtered_pairs = sorted(filtered_pairs, key=lambda x: abs(x[1] - target_q_z))
        closest_by_qz = [pair for pair in filtered_pairs if abs(pair[1] - target_q_z) <= tol1]
        closest_by_qz = sorted(closest_by_qz, key=lambda x: abs(x[0] - target_q_xy))
        closest_by_qxy = [pair for pair in closest_by_qz if abs(pair[0] - target_q_xy) <= tol2]
        
        if not closest_by_qxy:  # Check if the list is empty
            return None

        closest_point = min(closest_by_qxy, key=lambda x: abs(x[1] - target_q_z))
        return closest_point

    def azimuthal_crop(self, data: xr.DataArray, qr_range: list, chi_range: list):
        qr_min, qr_max = min(qr_range), max(qr_range)
        chi_min, chi_max = min(chi_range), max(chi_range)
        
        # Initialize corners dictionary
        corners = {}

        # Create an empty mask with the same shape as the input DataArray
        mask = np.zeros(data.shape, dtype=bool)

        # Convert the 2D DataArray to a list of (q_xy, q_z) pairs
        q_xy_vals, q_z_vals = np.meshgrid(data['q_xy'].values, data['q_z'].values)
        pairs = list(zip(q_xy_vals.ravel(), q_z_vals.ravel()))

        # For Arc Cropping
        for qr in [qr_min, qr_max]:
            chi_values = np.linspace(chi_min, chi_max, 100)
            for chi in chi_values:
                chi_rad = np.radians(chi)
                q_xy = qr * np.sin(chi_rad)
                q_z = qr * np.cos(chi_rad)
                closest_point = self.find_closest_point(pairs, q_xy, q_z)
                
                if closest_point:
                    closest_idx = data.sel(q_xy=closest_point[0], q_z=closest_point[1], method='nearest').indexes
                    mask[closest_idx] = True

        # For Line Cropping
        for chi in [chi_min, chi_max]:
            chi_rad = np.radians(chi)
            for qr in np.linspace(qr_min, qr_max, 100):
                q_xy = qr * np.sin(chi_rad)
                q_z = qr * np.cos(chi_rad)
                closest_point = self.find_closest_point(pairs, q_xy, q_z)
                
                if closest_point:
                    closest_idx = data.sel(q_xy=closest_point[0], q_z=closest_point[1], method='nearest').indexes
                    mask[closest_idx] = True
                    corners[(qr, chi)] = closest_point  # Storing the corners
        
        self.corners = corners  # Assigning corners to self attribute
        self.mask = mask  # Update self.mask here

        # Use binary_fill_holes from scipy.ndimage to fill the inside of the mask
        filled_mask = ndi.binary_fill_holes(self.mask)

        # Update the mask and cropped_data with the filled mask
        self.mask = filled_mask
        self.cropped_data = data.where(filled_mask)

        return self.cropped_data, self.corners
    
    def azimuthal_crop(self, data: xr.DataArray, qr_range: list, chi_range: list):
        # Step 1: Generate the overlay shape
        shape = []
        self.generate_overlay_shape(qr_range, chi_range, shape)

        # Convert the 2D DataArray to a list of (q_xy, q_z) pairs
        q_xy_vals, q_z_vals = np.meshgrid(data['q_xy'].values, data['q_z'].values)
        pairs = list(zip(q_xy_vals.ravel(), q_z_vals.ravel()))

        # Create an empty mask with the same shape as the input DataArray
        mask = np.zeros(data.shape, dtype=bool)

        # Step 2: Find closest points
        for point in shape:
            q_xy, q_z = point
            closest_point = self.find_closest_point(pairs, q_xy, q_z)
            if closest_point:
                closest_idx = data.sel(q_xy=closest_point[0], q_z=closest_point[1], method='nearest').indexes
                mask[closest_idx] = True

        # Step 3: Create mask from shape
        # Convert shape to an array for ConvexHull
        shape_array = np.array(shape)
        
        # Calculate the convex hull of the shape
        hull = ConvexHull(shape_array)
        
        for simplex in hull.simplices:
            # mask[data['q_xy'].values == shape_array[simplex, 0], data['q_z'].values == shape_array[simplex, 1]] = True
            # Create a Delaunay object based on the convex hull
            tri = Delaunay(shape_array)

            # Loop through all data points
            for i, q_xy in enumerate(data['q_xy'].values):
                for j, q_z in enumerate(data['q_z'].values):
                    # Check if point is within any of the Delaunay triangles
                    if tri.find_simplex((q_xy, q_z)) >= 0:
                        mask[j, i] = True

        # Step 4: Fill the inside of the mask
        filled_mask = ndi.binary_fill_holes(mask)

        # Update the mask and cropped_data with the filled mask
        self.mask = filled_mask
        self.cropped_data = data.where(filled_mask)
        
        return self.cropped_data, self.shape

    # @staticmethod
    def generate_overlay_shape(self, qr_range, chi_range, shape):
        # Generate the coordinates for the overlay shape based on the qr and chi ranges
        qr_min, qr_max = qr_range
        chi_min, chi_max = chi_range

        # Generate points along the arc for each qr value
        for qr in [qr_min, qr_max]:
            chi_values = np.linspace(chi_min, chi_max, 100)  # Generate chi_values along the arc
            for chi in chi_values:
                chi_rad = np.radians(chi)
                q_xy = qr * np.sin(chi_rad)
                q_z = qr * np.cos(chi_rad)
                shape.append((q_xy, q_z))

        # Generate points along the lines for each chi value
        for chi in [chi_min, chi_max]:
            chi_rad = np.radians(chi)
            for qr in np.linspace(qr_min, qr_max, 100):  # Walk from qr_max to qr_min
                q_xy = qr * np.sin(chi_rad)
                q_z = qr * np.cos(chi_rad)
                shape.append((q_xy, q_z))

        self.shape = shape      
        return self.shape

    # @staticmethod
    def plot_with_overlay(self, img, qr_range, chi_range, corners):
        # Initialize shape as an empty list
        shape = []

        # Generate the shape overlay
        shape = self.generate_overlay_shape(qr_range, chi_range, shape)

        # Extract shape coordinates for plotting
        shape_x, shape_y = zip(*shape)

        # Extract q_xy and q_z values from 'img' for plotting
        q_xy_vals = img['q_xy'].values
        q_z_vals = img['q_z'].values

        # Extract the coordinates of the corners for plotting
        q_xy_corner_vals = [coord[0] for coord in corners.values()]
        q_z_corner_vals = [coord[1] for coord in corners.values()]

        # Plot the data
        plt.figure(figsize=(10, 10))
        plt.imshow(img.values, extent=[q_xy_vals[0], q_xy_vals[-1], q_z_vals[0], q_z_vals[-1]], 
                origin='lower', aspect='auto', cmap='viridis')

        # Overlay the corners
        # plt.scatter(q_xy_corner_vals, q_z_corner_vals, color='red', marker='x', s=100, label='Corners')

        # Overlay the shape
        plt.scatter(shape_x, shape_y, c='white', s=10, alpha=0.5, label='Cropped Area')

        # Labels and title
        plt.xlabel('q_xy')
        plt.ylabel('q_z')
        plt.title('2D Data with Corners and Overlay for Azimuthal Integration')
        plt.legend()

        plt.show()

    def apply_mask_to_data(self, new_data: xr.DataArray):
        """
        Apply the stored mask to a new data array.

        Parameters:
        new_data : xr.DataArray
            A new 2D data array with coordinates 'q_xy' and 'q_z'.

        Returns:
        cropped_new_data : xr.DataArray
            The new data array after applying the mask.
        """
        if self.mask is None:
            raise ValueError("Mask has not been generated. Run azimuthal_crop first.")
        
        # Make sure the new data array has the same shape as the mask
        if new_data.shape != self.mask.shape:
            raise ValueError("The shape of the new data array does not match the shape of the mask.")

        cropped_new_data = new_data.where(self.mask)
        return cropped_new_data

    # Adding a method to plot cropped data to the existing WAXSTest class
    def plot_cropped_data(self):
        """
        Plot the cropped data stored in self.cropped_data.
        """
        if self.cropped_data is None:
            raise ValueError("Cropped data is not available. Run azimuthal_crop first.")
        
        # Extract q_xy and q_z values from the cropped data for plotting
        q_xy_vals = self.cropped_data['q_xy'].values
        q_z_vals = self.cropped_data['q_z'].values
        
        # Plot the data
        plt.figure(figsize=(10, 10))
        plt.imshow(self.cropped_data.values, extent=[q_xy_vals[0], q_xy_vals[-1], q_z_vals[0], q_z_vals[-1]], 
                   origin='lower', aspect='auto', cmap='viridis')
        
        # Labels and title
        plt.xlabel('q_xy')
        plt.ylabel('q_z')
        plt.title('Cropped 2D Data for Azimuthal Integration')
        
        plt.show()

    @staticmethod
    def to_polar(q_xy, q_z):
        qr = np.sqrt(q_xy ** 2 + q_z ** 2)
        chi = np.degrees(np.arctan2(q_xy, q_z))
        return round(qr, 4), round(chi, 4)  # Rounding to avoid floating-point errors

    @staticmethod
    def to_cartesian(qr, chi):
        chi_rad = np.radians(chi)
        q_xy = qr * np.sin(chi_rad)
        q_z = qr * np.cos(chi_rad)
        return round(q_xy, 4), round(q_z, 4)  # Rounding to avoid floating-point errors

    @staticmethod
    def clean_float(value, tol=1e-10):
        return value if abs(value) > tol else 0.0

    def determine_bins(self):
        # Count the number of unique points along each line and arc in the mask
        unique_qr_line = len(np.unique(self.mask.nonzero()[0]))
        unique_chi_arc = len(np.unique(self.mask.nonzero()[1]))
        
        # Determine the number of bins based on the shortest line and arc
        num_qr_bins = unique_qr_line
        num_chi_bins = unique_chi_arc

        return num_qr_bins, num_chi_bins

    def azimuthal_integration(self, data: xr.DataArray):
        num_qr_bins, num_chi_bins = self.determine_bins()
        
        # Initialize the sum array for azimuthal integration
        azimuthal_sum = np.zeros(num_qr_bins)
        
        # Initialize the bins
        qr_bins = np.linspace(data['qr'].min(), data['qr'].max(), num_qr_bins)
        chi_bins = np.linspace(data['chi'].min(), data['chi'].max(), num_chi_bins)
        
        # Loop through the qr bins
        for i in range(len(qr_bins) - 1):
            qr_min = qr_bins[i]
            qr_max = qr_bins[i + 1]
            
            # Extract the subset of the data within this qr bin
            subset = data.where((data['qr'] >= qr_min) & (data['qr'] < qr_max), drop=True)
            
            # Sum over all chi values in this qr bin
            azimuthal_sum[i] = subset.sum().values
        
        return qr_bins[:-1], azimuthal_sum  # Return the qr bins and the azimuthal sum

    def plot_azimuthal_integration(self, qr, azimuthal_sum):
        plt.figure(figsize=(10, 6))
        plt.plot(qr, azimuthal_sum, marker='o')
        plt.xlabel('qr')
        plt.ylabel('Azimuthal Sum')
        plt.title('1D Azimuthal Integration')
        plt.grid(True)
        plt.show()

    def _create_azimuthal_matrix(self, chi, qr, mask, chi_range, qr_range, discretization, sum_direction):
        rows, cols, data = [], [], []
        values = np.arange(chi_range[0], chi_range[1], discretization) if sum_direction == 'chi' else np.arange(qr_range[0], qr_range[1], discretization)
        
        for i, val in enumerate(values):
            lower_bound = val
            upper_bound = val + discretization
            local_mask = mask & (chi >= lower_bound) & (chi < upper_bound) if sum_direction == 'chi' else \
                        mask & (qr >= lower_bound) & (qr < upper_bound)
                        
            pixel_indices = np.nonzero(local_mask)
            
            # Add a check to see if pixel_indices[0] is empty
            if pixel_indices[0].size > 0:
                # Debug: Check the maximum index value in pixel_indices[0]
                print("Max index in pixel_indices[0]:", np.max(pixel_indices[0]))
            else:
                print("pixel_indices[0] is empty.")
            
            # Debug: Check the shapes of chi and qr
            print("Shape of chi:", chi.shape)
            print("Shape of qr:", qr.shape)
            print("Max index in pixel_indices[0]:", np.max(pixel_indices[0]) if pixel_indices[0].size > 0 else "N/A")

            # Remove out-of-bounds indices
            pixel_indices = [idx for idx in pixel_indices[0] if idx < chi.shape[0] - 1]

            for j in pixel_indices:
                if j >= chi.shape[0]:
                    print(f"Index out of bounds for chi: {j}")
                elif j >= qr.shape[0]:
                    print(f"Index out of bounds for qr: {j}")
                
                rows.append(i)
                cols.append(j)
                chi_np = chi.values
                qr_np = qr.values

                pixel_split_factor = np.abs(chi_np[j] - val) / discretization if sum_direction == 'chi' else \
                                    np.abs(qr_np[j] - val) / discretization

                data.append(pixel_split_factor)


        return csr_matrix((data, (rows, cols)))

        @staticmethod
        def convert_to_chi_qr(qxy, qz):
            chi = np.arctan2(qz, qxy) * (180 / np.pi)
            qr = np.sqrt(qxy ** 2 + qz ** 2)
            return chi, qr

        @staticmethod
        def generate_mock_data_with_variable_intensity(size=200, num_arcs=5, intensity_base=100, intensity_variation=20):
            x, y = np.linspace(-size // 2, size // 2, size), np.linspace(-size // 2, size // 2, size)
            xx, yy = np.meshgrid(x, y)
            rr = np.sqrt(xx ** 2 + yy ** 2)
            angle = np.arctan2(yy, xx)

            img = np.zeros((size, size))
            for i in range(1, num_arcs + 1):
                arc_mask = np.abs(rr - i * 10) < 1
                img[arc_mask] = intensity_base + intensity_variation * np.sin(3 * angle[arc_mask])

            img[:, :size // 2] = 0
            return img

        @staticmethod
        def interpolate_along_chi(chi, qr, img):
            chi_values = np.unique(chi)
            interpolated_img = np.zeros_like(img)

            for chi_val in chi_values:
                mask = chi == chi_val
                qr_values = qr[mask]
                img_values = img[mask]
                if len(qr_values) < 2:
                    continue
                interpolator = interp1d(qr_values, img_values, kind='linear', fill_value='extrapolate')
                interpolated_img[mask] = interpolator(qr[mask])

            return interpolated_img

    def azimuth1D(self, img, chi_range, qr_range, sum_direction, discretization=0.1):
        """
        Description:
        Takes a 2D Xarray DataArray and performs azimuthal integration over a specified range of chi and qr values.

        Variables:
        - img: Input Xarray DataArray with 'qxy' and 'qz' as coordinates.
        - chi_range: A tuple (chi_min, chi_max) specifying the range of chi values for integration.
        - qr_range: A tuple (qr_min, qr_max) specifying the range of qr values for integration.
        - sum_direction: A string specifying the direction along which to sum ('chi' or 'qr').
        - discretization: A float specifying the step size for the azimuthal sum.

        Attributes:
        - self.azimuth1D_xr_sum: Stores the resulting 1D DataArray after azimuthal integration.
        - self.azimuth_mask: Stores the mask used for slicing the image based on chi and qr ranges.
        - self.original_total_intensity: Stores the original total intensity of the masked image for verification.

        Output:
        Returns the 1D DataArray after azimuthal integration and stores it in self.azimuth1D_xr_sum.
        
        """
        # Step 1: Input Validation
        qz_aliases = ['qz', 'q_z', 'QZ', 'Q_z', 'Q_Z']
        qxy_aliases = ['qxy', 'q_xy', 'QXY', 'Qxy', 'Q_xy', 'Q_XY']

        qz_dim = None
        qxy_dim = None
        for dim in img.dims:
            if dim in qz_aliases:
                qz_dim = dim
            if dim in qxy_aliases:
                qxy_dim = dim

        if qz_dim is None or qxy_dim is None:
            raise ValueError("The input DataArray must have 'qxy' or an alias and 'qz' or an alias as dimensions.")

        # if 'qxy' not in img.coords or 'qz' not in img.coords:
        #     raise ValueError("The input DataArray must have 'qxy' and 'qz' as coordinates.")

        chi_min, chi_max = chi_range
        qr_min, qr_max = qr_range

        if sum_direction not in ['chi', 'qr']:
            raise ValueError("Invalid sum_direction. Choose either 'chi' or 'qr'.")

        # Step 2: Coordinate Conversion
        qxy = img[qxy_dim]
        qz = img[qz_dim]

        # Debugging: Check the range of qxy, qz, chi, and qr
        print(f"qxy range: {qxy.min().item()}, {qxy.max().item()}")
        print(f"qz range: {qz.min().item()}, {qz.max().item()}")

        chi = np.arctan2(qz, qxy) * (180 / np.pi)
        qr = np.sqrt(qxy**2 + qz**2)

        print(f"chi range: {chi.min().item()}, {chi.max().item()}")
        print(f"qr range: {qr.min().item()}, {qr.max().item()}")

        # Step 3: Masking and Slicing
        mask = (chi >= chi_min) & (chi <= chi_max) & (qr >= qr_min) & (qr <= qr_max)

        # Debug: Check the min/max values in the mask
        print(f"Mask min/max: {mask.min().item()}, {mask.max().item()}")

        # Debug: Check the number of True values in the mask
        print(f"Number of True values in mask: {mask.sum().item()}")

        self.azimuth_mask = mask
        self.original_total_intensity = img.where(mask).sum().item()

        # Debug: Check original_total_intensity
        print(f"Original total intensity: {self.original_total_intensity}")

        self.azimuth_mask = mask
        self.original_total_intensity = img.where(mask).sum().item()

        # Step 4: Azimuthal Summation
        chi_values = np.arange(chi_min, chi_max, discretization)
        qr_values = np.arange(qr_min, qr_max, discretization)

        sum_array = np.zeros(len(chi_values) if sum_direction == 'chi' else len(qr_values))

        print(f"Original total intensity: {self.original_total_intensity}")

        # Inside the for loop
        for i, val in enumerate(chi_values if sum_direction == 'chi' else qr_values):
            lower_bound = val
            upper_bound = val + discretization
            
            # Debug: Check the lower and upper bounds
            print(f"Lower bound for index {i}: {lower_bound}, Upper bound for index {i}: {upper_bound}")

            local_mask = mask & (chi >= lower_bound) & (chi < upper_bound) if sum_direction == 'chi' else \
                        mask & (qr >= lower_bound) & (qr < upper_bound)

            # Debug: Print the number of true values in local_mask
            print(f"Number of True values in local_mask for index {i}: {local_mask.sum().item()}")

            # Debug: Print the local intensity sum
            local_intensity = img.where(local_mask).sum().item()
            print(f"Local intensity sum for index {i}: {local_intensity}")

            # Debug: Print the pixel split factor
            pixel_split_factor = np.abs(chi - val) / discretization if sum_direction == 'chi' else \
                                np.abs(qr - val) / discretization
            print(f"Pixel split factor for index {i}: {pixel_split_factor.sum().item()}")

            sum_array[i] = (local_intensity * pixel_split_factor).sum().item()

        self.azimuth1D_xr_sum = xr.DataArray(sum_array, coords=[chi_values if sum_direction == 'chi' else qr_values], dims=[sum_direction])

        # Debugging prints
        print(f"Sum of azimuth1D_xr_sum: {self.azimuth1D_xr_sum.sum().item()}")

        if not np.isclose(self.azimuth1D_xr_sum.sum().item(), self.original_total_intensity, atol=1e-6):
            raise ValueError("Pixel splitting error: Total intensity mismatch.")

        return self.azimuth1D_xr_sum

        '''